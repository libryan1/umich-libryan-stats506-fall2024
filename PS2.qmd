---
title: "STATS 506 Problem Set 2"
format: html
editor: visual
---

Problem 1 - Dice Game

a.  

```{r}
library(roxygen2)
```


```{r}
# Loop
play_dice_loop <- function(n) {
  #' Plays dice game using loop
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- sample(1:6, n, replace = TRUE)
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls <- n * 2 
  
    # Iterates through each roll, adds that roll * 2 to wins_from_rolls so long 
    # as roll isn't 3 or 5.
  wins_from_rolls <- 0
  for (roll in rolls) {
    if (roll != 3 & roll != 5) {
      wins_from_rolls = wins_from_rolls + roll * 2
    } else {
      next
    }
  }
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
# Built-in vectorized functions
play_dice_vec <- function(n) {
  #' Plays dice game using vectors
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- sample(1:6, n, replace = TRUE)
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls <- n * 2 
  
    # Calculates sum of all rolls that aren't 3 or 5 and multiplies the sum by 2
    # to acquire $ won from rolls.  This is algebraically equivalent to 
    # multiplying each individual roll by 2 that aren't 3 or 5 and then summing
    # those products.  All of this is done in vectorized format to the vector
    # storing the rolls
  wins_from_rolls <- sum(rolls[rolls != 3 & rolls != 5]) * 2
  
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
# Table
play_dice_table <- function(n) {
  #' Plays dice game using table
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- sample(1:6, n, replace = TRUE)
  
  
  # Put rolls into table
    # factor function when used with table creates 0 columns, where possible
    # dice roll outcomes that did not occur are recorded as 0 in the table
  table_rolls <- table(factor(rolls, levels = 1:6))
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls = n * 2
  
    # Acquires the number of times a roll that wasn't 3 or 5 occurred using the
    # table.  Then takes those numbers, multiplies it by the value of the dice 
    # and then by 2, then sums it all together.  This is algebraically 
    # equivalent to taking each roll that wasn't 3 or 5, multiplying them by 2, 
    # and then summing.
  n_1 = as.numeric(table_rolls['1'])
  n_2 = as.numeric(table_rolls['2'])
  n_4 = as.numeric(table_rolls['4'])
  n_6 = as.numeric(table_rolls['6'])
  wins_from_rolls = n_1*1*2 + n_2*2*2 + n_4*4*2 + n_6*6*2
  
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
# Apply
play_dice_apply <- function(n) {
  #' Plays dice game using apply family
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- sample(1:6, n, replace = TRUE)
  
  
  # Put rolls into dataframe with 4 columns that track which of the winning 
  # rolls a roll was.  Each row is one of the n rows, with a 1 in one of the
  # columns to indicate if it was that specific winning roll, and 0 otherwise.
  ones <- rep(0, n)
  twos <- rep(0, n)
  fours <- rep(0, n)
  sixes <- rep(0, n)
  ones[rolls == 1] <- 1
  twos[rolls == 2] <- 1
  fours[rolls == 4] <- 1
  sixes[rolls == 6] <- 1
  rolls_df <- data.frame(is_1 = ones, is_2 = twos, is_4 = fours, is_6 = sixes)
  
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls <- n * 2
  
    # Uses lapply to find sum of each column in the rolls dataframe, which gets
    # the total number of rolls for each possible roll that would have won.
  winning_rolls <- lapply(rolls_df, sum)
  n_1 <- winning_rolls$is_1
  n_2 <- winning_rolls$is_2
  n_4 <- winning_rolls$is_4
  n_6 <- winning_rolls$is_6
  wins_from_rolls = n_1*1*2 + n_2*2*2 + n_4*4*2 + n_6*6*2
  
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```


b.

```{r}
play_dice_loop(3)
play_dice_loop(3000)

play_dice_vec(3)
play_dice_vec(3000)

play_dice_table(3)
play_dice_table(3000)

play_dice_apply(3)
play_dice_apply(3000)
```

c.

```{r}
# Loop
# Seed fixed for sample function, identical otherwise
play_dice_loop_fixed <- function(n) {
  #' Plays dice game using loop, dice rolls are fixed
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- {set.seed(1); sample(1:6, n, replace = TRUE)}
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls <- n * 2 
  
    # Iterates through each roll, adds that roll * 2 to wins_from_rolls so long 
    # as roll isn't 3 or 5.
  wins_from_rolls <- 0
  for (roll in rolls) {
    if (roll != 3 & roll != 5) {
      wins_from_rolls = wins_from_rolls + roll * 2
    } else {
      next
    }
  }
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
# Built-in vectorized functions
# Seed fixed for sample function, identical otherwise
play_dice_vec_fixed <- function(n) {
  #' Plays dice game using vectors, dice rolls are fixed
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- {set.seed(1); sample(1:6, n, replace = TRUE)}
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls <- n * 2 
  
    # Calculates sum of all rolls that aren't 3 or 5 and multiplies the sum by 2
    # to acquire $ won from rolls.  This is algebraically equivalent to 
    # multiplying each individual roll by 2 that aren't 3 or 5 and then summing
    # those products.  All of this is done in vectorized format to the vector
    # storing the rolls
  wins_from_rolls <- sum(rolls[rolls != 3 & rolls != 5]) * 2
  
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
# Table
# Seed fixed for sample function, identical otherwise
play_dice_table_fixed <- function(n) {
  #' Plays dice game using table, dice rolls are fixed
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- {set.seed(1); sample(1:6, n, replace = TRUE)}
  
  
  # Put rolls into table
    # factor function when used with table creates 0 columns, where possible
    # dice roll outcomes that did not occur are recorded as 0 in the table
  table_rolls <- table(factor(rolls, levels = 1:6))
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls = n * 2
  
    # Acquires the number of times a roll that wasn't 3 or 5 occurred using the
    # table.  Then takes those numbers, multiplies it by the value of the dice 
    # and then by 2, then sums it all together.  This is algebraically 
    # equivalent to taking each roll that wasn't 3 or 5, multiplying them by 2, 
    # and then summing.
  n_1 = as.numeric(table_rolls['1'])
  n_2 = as.numeric(table_rolls['2'])
  n_4 = as.numeric(table_rolls['4'])
  n_6 = as.numeric(table_rolls['6'])
  wins_from_rolls = n_1*1*2 + n_2*2*2 + n_4*4*2 + n_6*6*2
  
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
# Apply
# Seed fixed for sample function, identical otherwise
play_dice_apply_fixed <- function(n) {
  #' Plays dice game using apply family, dice rolls are fixed
  #' @param n a numeric vector of length 1
  #' @return The profit from playing the dice game `n` times'
  
  
  # Sanitizing statement
  if (is.numeric(n) != TRUE) {
    stop('n must be numeric')
  } else if (length(n) > 1) {
    stop('n must be vector of length 1')
  }
  
  
  # Get rolls
    # Built-in sample function, stores all rolls within a vector.
  rolls <- {set.seed(1); sample(1:6, n, replace = TRUE)}
  
  
  # Put rolls into dataframe with 4 columns that track which of the winning 
  # rolls a roll was.  Each row is one of the n rows, with a 1 in one of the
  # columns to indicate if it was that specific winning roll, and 0 otherwise.
  ones <- rep(0, n)
  twos <- rep(0, n)
  fours <- rep(0, n)
  sixes <- rep(0, n)
  ones[rolls == 1] <- 1
  twos[rolls == 2] <- 1
  fours[rolls == 4] <- 1
  sixes[rolls == 6] <- 1
  rolls_df <- data.frame(is_1 = ones, is_2 = twos, is_4 = fours, is_6 = sixes)
  
  
  
  # Calculate winnings
    # Each roll costs $2 
  fees_from_rolls <- n * 2
  
    # Uses lapply to find sum of each column in the rolls dataframe, which gets
    # the total number of rolls for each possible roll that would have won.
  winning_rolls <- lapply(rolls_df, sum)
  n_1 <- winning_rolls$is_1
  n_2 <- winning_rolls$is_2
  n_4 <- winning_rolls$is_4
  n_6 <- winning_rolls$is_6
  wins_from_rolls = n_1*1*2 + n_2*2*2 + n_4*4*2 + n_6*6*2
  
    # Computes $ taken home after costs of playing are accounted for
  winnings <- wins_from_rolls - fees_from_rolls
  
  
  # Return profit from game
  return(winnings)
}
```

```{r}
play_dice_loop_fixed(3)
play_dice_loop_fixed(3000)

play_dice_vec_fixed(3)
play_dice_vec_fixed(3000)

play_dice_table_fixed(3)
play_dice_table_fixed(3000)

play_dice_apply_fixed(3)
play_dice_apply_fixed(3000)
```

d.

```{r}
library(microbenchmark)
# Seeds fixed to make written portion make sense
loop1k <- microbenchmark(play_dice_loop(1000), unit = 'microseconds')
loop100k <- microbenchmark(play_dice_loop(100000), unit = 'microseconds')

vec1k <- microbenchmark(play_dice_vec(1000), unit = 'microseconds')
vec100k <- microbenchmark(play_dice_vec(100000), unit = 'microseconds')

table1k <- microbenchmark(play_dice_table(1000), unit = 'microseconds')
table100k <- microbenchmark(play_dice_table(100000), unit = 'microseconds')

apply1k <- microbenchmark(play_dice_apply(1000), unit = 'microseconds')
apply100k <- microbenchmark(play_dice_apply(100000), unit = 'microseconds')

print(loop1k)
print(loop100k)
print(vec1k)
print(vec100k)
print(table1k)
print(table100k)
print(apply1k)
print(apply100k)
```

In terms of mean run times, for 1000 apply is the slowest, then loop and table with vectorized being the quickest.  For 100,000 loop is the slowest, table and apply are about the same, and vectorized is by far the quickest.  Overall vectorized is the best if execution times are a concern.  Apply should only be used when there is a lot of data and vectorized methods cannot be used.  Tables should only be used when vectorized methods are unavailable.  Loops should only be used if execution times are irrelevant.

e.

```{r}
mean(replicate(100000, play_dice_vec(1)))
```

Yes this is a fair game.  We see that from a Monte Carlo simulation  of just 1 round of the dice game that the expected value of winnings, the profit from the game, is positive.  Thus You will overall win more money than you lose by playing this game, as each each round has a higher chance of you making a profit than losing money.
